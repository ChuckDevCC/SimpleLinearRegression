# -*- coding: utf-8 -*-
"""CFS-Research Notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JU7kNGPGNSN6YDbCZoYNG_HFYnr5TFEH

# Final Project - Notebook
"""

# make use of our personal google drive
from google.colab import drive

# Using outside libraries that will help with calculations:
# Numerical Python as numpy for number analysis
# pandas as panel data, to help format
# matplotlib with pyplot to graph the results
# and sklearn for the linear regression model.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import PolynomialFeatures
from collections import defaultdict
import os

# mount our google drive to the virtual server
drive.mount('/content/gdrive')

cd gdrive/

cd My\ Drive

# import the csv file from google drive
ledger = pd.read_csv('NFA 2018.csv')

ledger

"""## Analysis
I have chosen 5 psuedo-random countries to conduct for the models. This is based on the factors of quantity, readability, and location. A survey of a small sample was conducted from my inner peer group to select a country from every continent, and these were the results of their choices. These will be the subjects of the study. Due to some missing data, this study will trim any zero data points for the most accuracy.
"""

countryNames = ["Canada","Japan","Ireland","Nigeria","Australia"]

# to find the starting and end values of our countries
# based on the size of the read data, find the range where
# the ledger has the listing of selected countries
countryRange = []
for i in range(5):
  countryRange.append(np.where(ledger["country"] == countryNames[i]))

"""Once the range is found on all countries, we can find simple variables to use as a baseline reference. Use the iloc[ ], .head( ), and .tail( ) functions to store the indices of the start and end. iterate through the list of lists using the 'for' function, and trim as necessary."""

countryStart = []
for i in range(5):
  countryStart.append(ledger.iloc[countryRange[i]].head(1).index[0])

countryEnd = []
for i in range(5):
  countryEnd.append(ledger.iloc[countryRange[i]].tail(1).index[0])

# declare five empty list of lists
# X for total hectare land
# Y for Carbon Consumption
# Z for Population
# H for years
dataX = [[] for _ in range(5)]
dataY = [[] for _ in range(5)]
dataZ = [[] for _ in range(5)]
dataH = [[] for _ in range(5)]

# write data from the ledger columns
# starting at the first index of selected
# country and interate to last,
# then append to lists
for i in range(5):
  for j in range(countryStart[i],countryEnd[i]):
    dataX[i].append(ledger.iloc[j]["total"])
    dataY[i].append(ledger.iloc[j]["carbon"])
    dataZ[i].append(ledger.iloc[j]["population"])
    dataH[i].append(ledger.iloc[j]["year"])

# Make new lists to trim
# any zero elements in our Carbon measure
# and save for every other list.
dataX_ = [[] for _ in range(5)]
dataY_ = [[] for _ in range(5)]
dataZ_ = [[] for _ in range(5)]
dataH_ = [[] for _ in range(5)]

for i in range(5):
  for x in range(len(dataY[i])):
    if dataY[i][x] != 0:
      dataY_[i].append(dataY[i][x])
      dataX_[i].append(dataX[i][x])
      dataZ_[i].append(dataZ[i][x])
      dataH_[i].append(dataH[i][x])

"""## Implementation of Machine Learning
The next module will use machine learning tactics with the application of the LinearRegression() model. This helps us see the correlation between the data points we have chosen. It requires five different training sets, so as to not overlap the data. This is because we 'train' the machine to predict they y points based on our current x and y values. We use the y prediction list and regular y list to see the difference between what the algorithm expects and what we have.
"""

regression_model1 = LinearRegression()
regression_model2 = LinearRegression()
regression_model3 = LinearRegression()
regression_model4 = LinearRegression()
regression_model5 = LinearRegression()

# reshape the list of lists
# so the algorithm can read the data
# accurately and correctly
reshape = [[] for _ in range(5)]

for i in range(5):
  reshape[i] = np.array(dataX_[i]).reshape(-1,1)

# give the model training data
# for ever country
regression_model1.fit(reshape[0],dataY_[0])
regression_model2.fit(reshape[1],dataY_[1])
regression_model3.fit(reshape[2],dataY_[2])
regression_model4.fit(reshape[3],dataY_[3])
regression_model5.fit(reshape[4],dataY_[4])

yPredict = [[] for _ in range(5)]
r2 = [[] for _ in range(5)]
# create y predictions
# based on x values
yPredict[0] = regression_model1.predict(reshape[0])
yPredict[1] = regression_model2.predict(reshape[1])
yPredict[2] = regression_model3.predict(reshape[2])
yPredict[3] = regression_model4.predict(reshape[3])
yPredict[4] = regression_model5.predict(reshape[4])
# calculate the r2 value using
# new y predictions
for i in range(5):
  r2[i] = r2_score(dataY_[i],yPredict[i])

"""# Model and Interpretation

In the next module we will print the statistical data for the beginning and final data point of the country. If one was to delve further into this study, or is generally curious of the logistics, it will provide a simple log.

To interpret the items we made in the previous section, we will make graphical models of the data lists. The first graph will plot total hectare lands, which includes forestry, fishing, farming and city infrastructure, and plot it against the hectares needed to reach minimum 0 carbon footprint. The second graphical depiction is the population size per year. We use both graphs to deduce if there exists a relationship between the two models.
Further, We will apply a machine learning algorithm to find the relationship between the points, namely using linear regression.

After the graph the R-squared score will be produced. This indicates the relationship between the line of best fit to the data points on the graph. The closer to 1 this value becomes, the stronger the correlation.

## First Observation - Canada
"""

print(ledger.iloc[countryStart[0]])
print('#########################################')
print(ledger.iloc[countryEnd[0]])

plt.plot(dataX_[0],dataY_[0],'b.', label = "Carbon Production By Total Hectare Land")
plt.plot(dataX_[0],yPredict[0], 'r', label = "Linear Regression Analysis")
plt.xlabel('Total Hectare Land per Year')
plt.ylabel('Hectares Needed to Reach Carbon Equillibrium')
plt.title('Observation of Total Hectare Land by Year Comparable to Hectare Land Needed')
plt.legend()
plt.show()
print('R-squared score: ', r2[0])

plt.plot(dataH_[0], dataZ_[0],'c', label = "Carbon Production By Population")
plt.xlabel('Year over Year')
plt.ylabel('Population Size(per 1000)')
plt.title('Population Observation Year over Year')
plt.legend()
plt.show()

"""## Second Observation - Japan"""

print(ledger.iloc[countryStart[1]])
print('#########################################')
print(ledger.iloc[countryEnd[1]])

plt.plot(dataX_[1],dataY_[1],'b.', label = "Carbon Production By Total Hectare Land")
plt.plot(dataX_[1],yPredict[1], 'r', label = "Linear Regression Analysis")
plt.xlabel('Total Hectare Land per Year')
plt.ylabel('Hectares Needed to Reach Carbon Equillibrium')
plt.title('Observation of Total Hectare Land by Year Comparable to Hectare Land Needed')
plt.legend()
plt.show()
print('R-squared score: ', r2[1])

plt.plot(dataH_[1],dataZ_[1],'c', label = "Carbon Production By Population")
plt.xlabel('Year over Year')
plt.ylabel('Population Size(per 1000)')
plt.title('Population Observation Year over Year')
plt.legend()
plt.show()

"""## Third Observation - Ireland"""

print(ledger.iloc[countryStart[2]])
print('#########################################')
print(ledger.iloc[countryEnd[2]])

plt.plot(dataX_[2],dataY_[2],'b.', label = "Carbon Production By Total Hectare Land")
plt.plot(dataX_[2],yPredict[2], 'r', label = "Linear Regression Analysis")
plt.xlabel('Total Hectare Land per Year')
plt.ylabel('Hectares Needed to Reach Carbon Equillibrium')
plt.title('Observation of Total Hectare Land by Year Comparable to Hectare Land Needed')
plt.legend()
plt.show()
print('R-squared score: ', r2[2])

plt.plot(dataH_[2],dataZ_[2],'c', label = "Carbon Production By Population")
plt.xlabel('Year over Year')
plt.ylabel('Population Size(per 1000)')
plt.title('Population Observation Year over Year')
plt.legend()
plt.show()

"""## Fourth Observation - Nigeria"""

print(ledger.iloc[countryStart[3]])
print('#########################################')
print(ledger.iloc[countryEnd[3]])

plt.plot(dataX_[3],dataY_[3],'b.', label = "Carbon Production By Total Hectare Land")
plt.plot(dataX_[3],yPredict[3], 'r', label = "Linear Regression Analysis")
plt.xlabel('Total Hectare Land per Year')
plt.ylabel('Hectares Needed to Reach Carbon Equillibrium')
plt.title('Observation of Total Hectare Land by Year Comparable to Hectare Land Needed')
plt.legend()
plt.show()
print('R-squared score: ', r2[3])

plt.plot(dataH_[3],dataZ_[3],'c', label = "Carbon Production By Population")
plt.xlabel('Year over Year')
plt.ylabel('Population Size(per 1000)')
plt.title('Population Observation Year over Year')
plt.legend()
plt.show()

"""## Fifth Observation - Australia"""

print(ledger.iloc[countryStart[4]])
print('#########################################')
print(ledger.iloc[countryEnd[4]])

plt.plot(dataX_[4],dataY_[4],'b.', label = "Carbon Production By Total Hectare Land")
plt.plot(dataX_[4],yPredict[4], 'r', label = "Linear Regression Analysis")
plt.xlabel('Total Hectare Land per Year')
plt.ylabel('Hectares Needed to Reach Carbon Equillibrium')
plt.title('Observation of Total Hectare Land by Year Comparable to Hectare Land Needed')
plt.legend()
plt.show()
print('R-squared score: ', r2[4])

plt.plot(dataH_[4],dataZ_[4],'c', label = "Carbon Production By Population")
plt.xlabel('Year over Year')
plt.ylabel('Population Size(per 1000)')
plt.title('Population Observation Year over Year')
plt.legend()
plt.show()